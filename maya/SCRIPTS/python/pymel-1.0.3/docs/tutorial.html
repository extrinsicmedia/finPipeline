

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Getting Started &mdash; PyMEL v1.0.3 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PyMEL v1.0.3 documentation" href="index.html" />
    <link rel="next" title="PyNodes" href="pynodes.html" />
    <link rel="prev" title="Why PyMEL?" href="why_pymel.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pynodes.html" title="PyNodes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="why_pymel.html" title="Why PyMEL?"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PyMEL v1.0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="getting-started">
<h1>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<p>This tutorial assumes that you have some familiarity with python, but even if you only have MEL experience, you&#8217;ll probably be able to follow along. If you are a MEL scripter but have not used python in maya yet, you should start with the Maya docs on the subject, particularly the section <a class="reference external" href="http://download.autodesk.com/us/maya/2008help/General/Using_Python.html">Using Python</a>. This will help you to understand
the differences in syntax between the two languages and how to translate between them.</p>
<div class="section" id="formatting-read-me-first-to-avoid-confusion">
<h2>Formatting: Read Me First to Avoid Confusion<a class="headerlink" href="#formatting-read-me-first-to-avoid-confusion" title="Permalink to this headline">¶</a></h2>
<p>The code in these tutorials is formatted as you would see it in Maya&#8217;s Script Editor; however, the majority of the documentation outside of these tutorials is formatted as you would see it in a <a class="reference internal" href="standalone.html"><em>python interpreter</em></a>, which is standard for python documentation.</p>
<p>In an external interpreter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">nt.Camera(u&#39;frontShape&#39;)</span>
</pre></div>
</div>
<p>Maya&#8217;s script editor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c"># Result: frontShape</span>
</pre></div>
</div>
<p>You might notice that the differences go beyond formatting. Although it is not the case, it appears as though the same commands return two different results: <tt class="docutils literal"><span class="pre">nt.Camera(u'frontShape')</span></tt> and <tt class="docutils literal"><span class="pre">frontShape</span></tt>. Prior to version 2011, Autodesk chose to deviate from the standard python practice of using an object&#8217;s reproduction strings &#8211; as returned by <tt class="docutils literal"><span class="pre">repr()</span></tt> &#8211; to display results, instead they use the object&#8217;s string representation &#8211; as returned by <tt class="docutils literal"><span class="pre">str()</span></tt>.  This inevitably leads to confusion.</p>
<p>Here&#8217;s how you can get more informative results in the Script Editor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">repr</span><span class="p">(</span><span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="c"># Result: nt.Camera(u&#39;frontShape&#39;)</span>
</pre></div>
</div>
<p>here&#8217;s a shorthand for the same thing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sb">`ls(type=&#39;camera&#39;)[0]`</span>
<span class="c"># Result: nt.Camera(u&#39;frontShape&#39;)</span>
</pre></div>
</div>
</div>
<div class="section" id="example-1-the-basics">
<h2>Example 1: The Basics<a class="headerlink" href="#example-1-the-basics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="importing-pymel">
<h3>Importing PyMEL<a class="headerlink" href="#importing-pymel" title="Permalink to this headline">¶</a></h3>
<p>To get started we need to import the pymel module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymel.core</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This brings everything in pymel into the main namespace, meaning that you won&#8217;t have to prefix the maya commands with the module name.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>One problem with <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> is that importing it into the root namespace (e.g. <tt class="docutils literal"><span class="pre">from</span> <span class="pre">maya.cmds</span> <span class="pre">import</span> <span class="pre">*</span></tt>) is dangerous because it will override several of python&#8217;s more important built-in methods. PyMEL is designed to be safe to import into the root namespace so that scripts can be written much more concisely. However, if you are a python novice, you might want to keep pymel in its own namespace, because, <strong>unlike in MEL, in python you can &#8220;overwrite&#8221; functions if you are not careful</strong>:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pymel.core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">()</span> <span class="c"># create a nurbsSphere</span>
<span class="n">sphere</span> <span class="o">=</span> <span class="s">&#39;mySphere&#39;</span>  <span class="c"># oops, we&#39;ve overwritten the sphere command with a string</span>
<span class="n">sphere</span><span class="p">()</span>
<span class="c"># Error: name &#39;sphere&#39; is not defined</span>
<span class="c"># Traceback (most recent call last):</span>
<span class="c">#   File &quot;&lt;maya console&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="c"># NameError: name &#39;sphere&#39; is not defined #</span>
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All the functions in maya.cmds are in the pymel namespace, except the conflicting ones ( <tt class="docutils literal"><span class="pre">file</span></tt>, <tt class="docutils literal"><span class="pre">filter</span></tt>, <tt class="docutils literal"><span class="pre">eval</span></tt>, <tt class="docutils literal"><span class="pre">help</span></tt>, and <tt class="docutils literal"><span class="pre">quit</span></tt>). The conflicting commands can be found in the <tt class="xref py py-obj docutils literal"><span class="pre">pymel.cmds</span></tt> namespace, along with all of the unaltered maya commands.</p>
</div>
</div>
<div class="section" id="an-intro-to-pymel-objects-in-maya">
<h3>An Intro to PyMEL Objects in Maya<a class="headerlink" href="#an-intro-to-pymel-objects-in-maya" title="Permalink to this headline">¶</a></h3>
<p>Before we proceed let&#8217;s make sure we have a clean scene so that you&#8217;ll get the same results as me:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span><span class="o">=</span><span class="n">newFile</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c">#start clean</span>
</pre></div>
</div>
<p>Let&#8217;s start by listing the cameras in the scene.  We do this in the same way that we would with <tt class="docutils literal"><span class="pre">maya.cmds</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)</span>
<span class="c"># Result: [nt.Camera(u&#39;frontShape&#39;), nt.Camera(u&#39;perspShape&#39;), nt.Camera(u&#39;sideShape&#39;), nt.Camera(u&#39;topShape&#39;)]</span>
</pre></div>
</div>
<p>Just for comparison, let&#8217;s do the same thing using <tt class="docutils literal"><span class="pre">maya.cmds</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">maya.cmds</span> <span class="kn">as</span> <span class="nn">cmds</span>
<span class="n">cmds</span><span class="o">.</span><span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)</span>
<span class="c"># Result: [u&#39;frontShape&#39;, u&#39;perspShape&#39;, u&#39;sideShape&#39;, u&#39;topShape&#39;]</span>
</pre></div>
</div>
<p>Notice the difference in the returned results.  In the second example using <tt class="docutils literal"><span class="pre">maya.cmds</span></tt>, the <a class="reference internal" href="generated/functions/pymel.core.general/pymel.core.general.ls.html#pymel.core.general.ls" title="pymel.core.general.ls"><tt class="xref py py-obj docutils literal"><span class="pre">ls</span></tt></a> function returns a list of strings. For those of us coming from a MEL background, a list of names as strings is what we would expect out of <tt class="docutils literal"><span class="pre">ls</span></tt>. PyMEL returns something much better &#8211; instances of <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode" title="pymel.core.general.PyNode"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode</span></tt></a> classes &#8211; which are like strings on steroids. In addition to <a class="reference internal" href="#term-methods"><em class="xref std std-term">methods</em></a> for operating on node <em>names</em> as strings, these classes have methods for operating on the type of node or UI element that the string represents.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>object oriented programming introduces the concept of classes or &#8220;types&#8221;, and each occurrence of a type is called an instance. For example, a string is a <em>type</em> of object that represents a series of characters. An <em>instance</em> of a string could be the word &#8216;hello&#8217;.  You&#8217;ll probably find that the concepts behind object oriented programming are fairly familiar, because Maya itself is designed in a very object-oriented way. Maya has many types of nodes, each with its own attributes, properties, and capabilities. Each unique occurrence of one of these node types in your scene is like an instance of a class in python.</p>
<p class="last">The great thing about python is, unlike MEL, we&#8217;re not stuck with the default data types. We can make new types!  That&#8217;s a big part of what PyMEL adds: new Maya-specific data types to represent nodes, attributes, UI elements, vectors, matrices, etc.</p>
</div>
<p>Let&#8217;s use one of these camera objects to get some information.  To do this using <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> we might write something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cam</span> <span class="o">=</span> <span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">camera</span><span class="p">(</span> <span class="n">cam</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">aspectRatio</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># Result: 1.5</span>
<span class="n">camera</span><span class="p">(</span> <span class="n">cam</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">focalLength</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># Result: 35.0</span>
<span class="n">camera</span><span class="p">(</span> <span class="n">cam</span><span class="p">,</span> <span class="n">edit</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">focalLength</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>Rewriting this in an object-oriented way is fairly straight-forward:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cam</span> <span class="o">=</span> <span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">cam</span><span class="o">.</span><span class="n">getAspectRatio</span><span class="p">()</span>
<span class="c"># Result: 1.5</span>
<span class="n">cam</span><span class="o">.</span><span class="n">getFocalLength</span><span class="p">()</span>
<span class="c"># Result: 35.0</span>
<span class="n">cam</span><span class="o">.</span><span class="n">setFocalLength</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>The two examples start out the same way: with the <a class="reference internal" href="generated/functions/pymel.core.general/pymel.core.general.ls.html#pymel.core.general.ls" title="pymel.core.general.ls"><tt class="xref py py-obj docutils literal"><span class="pre">ls</span></tt></a> function. This is how we get our raw material to work with, in this case our node objects. In general, we can get nodes in 3 ways:</dt>
<dd><ul class="first last simple">
<li>list them based on some criteria</li>
<li>create them</li>
<li>get them by their name if we know it</li>
</ul>
</dd>
<dt>Once we have our list of nodes, we can begin to work in an object-oriented fashion. There is not a hard-fast rule for converting from a procedural style to an object-oriented one, but here are some general guidelines:</dt>
<dd><ul class="first last simple">
<li>the argument to the command &#8211; in this case <tt class="docutils literal"><span class="pre">cam</span></tt> &#8211; becomes the operating object on the left</li>
<li>instead of flags &#8211; <tt class="docutils literal"><span class="pre">focalLength</span></tt> and <tt class="docutils literal"><span class="pre">aspectRatio</span></tt> we use methods, which are attached to right of the object with a period <tt class="docutils literal"><span class="pre">.</span></tt></li>
<li>query methods are typically prefixed with &#8216;get&#8217; and edit methods are prefixed with &#8216;set&#8217;.  If a query does not have a corresponding edit, it may not have a &#8216;get&#8217; prefix.</li>
</ul>
</dd>
</dl>
<p>So, in our case <tt class="docutils literal"><span class="pre">query=True,</span> <span class="pre">aspectRatio=True</span></tt> becomes <tt class="docutils literal"><span class="pre">.getAspectRatio</span></tt>.  And <tt class="docutils literal"><span class="pre">query=True,</span> <span class="pre">focalLength=True</span></tt> becomes <tt class="docutils literal"><span class="pre">.getFocalLength</span></tt>.</p>
</div>
<div class="section" id="getting-help">
<h3>Getting Help<a class="headerlink" href="#getting-help" title="Permalink to this headline">¶</a></h3>
<p>If you are ever unsure of what method to use, just use the builtin python <tt class="docutils literal"><span class="pre">help</span></tt> command on the node class (the capitalized node type).  First find out what type of node you&#8217;re working with.  we&#8217;ll continue from the example above, with our <tt class="docutils literal"><span class="pre">cam</span></tt> variable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="nb">repr</span><span class="p">(</span><span class="n">cam</span><span class="p">)</span>
</pre></div>
</div>
<p>This prints <tt class="docutils literal"><span class="pre">nt.Camera(u'frontShape')</span></tt>. The <tt class="docutils literal"><span class="pre">nt.Camera</span></tt> part tells you what type of object it is. Now we can get help on that object type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">help</span><span class="p">(</span><span class="n">nt</span><span class="o">.</span><span class="n">Camera</span><span class="p">)</span>
</pre></div>
</div>
<p>This prints all the documentation on the <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.Camera.html#pymel.core.nodetypes.Camera" title="pymel.core.nodetypes.Camera"><tt class="xref py py-obj docutils literal"><span class="pre">Camera</span></tt></a> node type. If you want help on a particular method, you can do this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">help</span><span class="p">(</span><span class="n">nt</span><span class="o">.</span><span class="n">Camera</span><span class="o">.</span><span class="n">getFocalLength</span><span class="p">)</span>
</pre></div>
</div>
<p>You can do the same thing for any function as well:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">help</span><span class="p">(</span><span class="n">ls</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example-2-transitioning-from-procedural-programming">
<h2>Example 2: Transitioning from Procedural Programming<a class="headerlink" href="#example-2-transitioning-from-procedural-programming" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s look at another simple procedural example in which we find a camera, get it&#8217;s transform node, then get the z component of its translation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cam</span> <span class="o">=</span> <span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">parent</span> <span class="o">=</span> <span class="n">listRelatives</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">trans</span> <span class="o">=</span> <span class="n">xform</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="sb">`trans`</span>
<span class="c"># Result: [28.0, 21.0, 28.0]</span>
<span class="n">trans</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="c"># Result: 28.0</span>
</pre></div>
</div>
<p>Now let&#8217;s convert this to an object-oriented style.</p>
<p>Instead of <tt class="xref py py-obj docutils literal"><span class="pre">listRelatives</span></tt>, we can use use methods available on <tt class="docutils literal"><span class="pre">cam</span></tt>, which is a <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.Camera.html#pymel.core.nodetypes.Camera" title="pymel.core.nodetypes.Camera"><tt class="xref py py-obj docutils literal"><span class="pre">nodetypes.Camera</span></tt></a> class ( which can also be referred to by the shorthand <tt class="docutils literal"><span class="pre">nt.Camera</span></tt>). <tt class="docutils literal"><span class="pre">nodetypes.Camera</span></tt> inherits from <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.DagNode.html#pymel.core.nodetypes.DagNode" title="pymel.core.nodetypes.DagNode"><tt class="xref py py-obj docutils literal"><span class="pre">nodetypes.DagNode</span></tt></a>, so it has methods such as <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.DagNode.html#pymel.core.nodetypes.DagNode.getParent" title="pymel.core.nodetypes.DagNode.getParent"><tt class="xref py py-meth docutils literal"><span class="pre">getParent</span></tt></a>, and <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.DagNode.html#pymel.core.nodetypes.DagNode.getChildren" title="pymel.core.nodetypes.DagNode.getChildren"><tt class="xref py py-meth docutils literal"><span class="pre">getChildren</span></tt></a>.  In this case, we&#8217;ll use <tt class="docutils literal"><span class="pre">getParent</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cam</span> <span class="o">=</span> <span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">parent</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">getParent</span><span class="p">()</span> <span class="c"># &lt;---</span>
<span class="n">trans</span> <span class="o">=</span> <span class="n">xform</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="sb">`trans`</span>
<span class="c"># Result: [28.0, 21.0, 28.0]</span>
<span class="n">trans</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="c"># Result: 28.0</span>
</pre></div>
</div>
<p>Next, instead of <a class="reference internal" href="generated/functions/pymel.core.general/pymel.core.general.xform.html#pymel.core.general.xform" title="pymel.core.general.xform"><tt class="xref py py-obj docutils literal"><span class="pre">xform</span></tt></a>, we can use the <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.Transform.html#pymel.core.nodetypes.Transform.getTranslation" title="pymel.core.nodetypes.Transform.getTranslation"><tt class="xref py py-meth docutils literal"><span class="pre">getTranslation</span></tt></a> method of the <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.Transform.html#pymel.core.nodetypes.Transform" title="pymel.core.nodetypes.Transform"><tt class="xref py py-obj docutils literal"><span class="pre">nodetypes.Transform</span></tt></a> node:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cam</span> <span class="o">=</span> <span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">parent</span> <span class="o">=</span> <span class="n">cam</span><span class="o">.</span><span class="n">getParent</span><span class="p">()</span>
<span class="n">trans</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">getTranslation</span><span class="p">()</span> <span class="c"># &lt;---</span>
<span class="sb">`trans`</span>
<span class="c"># Result: dt.Vector([28.0, 21.0, 28.0])</span>
<span class="n">trans</span><span class="o">.</span><span class="n">z</span>
<span class="c"># Result: 28.0</span>
</pre></div>
</div>
<p>Now, let&#8217;s chain these commands together to compare procedural versus object-oriented.</p>
<p>procedural:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xform</span><span class="p">(</span> <span class="n">listRelatives</span><span class="p">(</span> <span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
<span class="c"># Result: 28.0</span>
</pre></div>
</div>
<p>object-oriented:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">ls</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">&#39;camera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">.</span><span class="n">getTranslation</span><span class="p">()</span><span class="o">.</span><span class="n">z</span>
<span class="c"># Result: 28.0</span>
</pre></div>
</div>
<p>In procedural programming, you take the result of one function and feed it into the arguments of another function, but in object oriented programming, functions are associated with &#8211; you might even say &#8220;attached to&#8221; &#8211; the returned objects themselves, so the chaining of functions is much easier to read.  The object-oriented approach is shorter even though the procedural approach uses short flag names that obscure their purpose.</p>
<p>One thing that should be clear by now is that you can continue to code in a procedural way using PyMEL, because the <tt class="xref py py-obj docutils literal"><span class="pre">pymel.core</span></tt> module provides the same set of <a class="reference internal" href="why_pymel.html#why-wrappers"><em>MEL-derived</em></a> commands as <tt class="docutils literal"><span class="pre">maya.cmds</span></tt>, but  PyMEL wraps all of these commands to return powerful PyMEL node classes, so you can begin mixing in object-oriented code as you become more comfortable with it.</p>
</div>
<div class="section" id="example-3-some-more-oo-basics">
<h2>Example 3: Some More OO Basics<a class="headerlink" href="#example-3-some-more-oo-basics" title="Permalink to this headline">¶</a></h2>
<p>Now let&#8217;s create a node:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">objs</span> <span class="o">=</span> <span class="n">polyPlane</span><span class="p">()</span>
<span class="n">objs</span>
<span class="c"># Result: [nt.Transform(u&#39;pPlane1&#39;), nt.PolyPlane(u&#39;polyPlane1&#39;)]</span>
</pre></div>
</div>
<p>You can see that, like the <a class="reference internal" href="generated/functions/pymel.core.general/pymel.core.general.ls.html#pymel.core.general.ls" title="pymel.core.general.ls"><tt class="xref py py-obj docutils literal"><span class="pre">ls</span></tt></a> command, the <a class="reference internal" href="generated/functions/pymel.core.modeling/pymel.core.modeling.polyPlane.html#pymel.core.modeling.polyPlane" title="pymel.core.modeling.polyPlane"><tt class="xref py py-obj docutils literal"><span class="pre">polyPlane</span></tt></a> command also returns <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode" title="pymel.core.general.PyNode"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode</span></tt></a> classes.  As in MEL, it returns a list: the first object is the tranform of the plane, and the second is the construction history. Now let&#8217;s get the shape of the transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># assign the transform from above to a variable</span>
<span class="n">plane</span> <span class="o">=</span> <span class="n">objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">shape</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">getShape</span><span class="p">()</span>
<span class="sb">`shape`</span>
<span class="c"># Result: nt.Mesh(u&#39;pPlaneShape1&#39;)</span>
</pre></div>
</div>
<p>So, we can clearly see that the shape is a Mesh. Let&#8217;s explore the <a class="reference internal" href="generated/classes/pymel.core.nodetypes/pymel.core.nodetypes.Mesh.html#pymel.core.nodetypes.Mesh" title="pymel.core.nodetypes.Mesh"><tt class="xref py py-obj docutils literal"><span class="pre">nodetypes.Mesh</span></tt></a> object a little. We can get the name as a string, formatted in different ways (the <tt class="docutils literal"><span class="pre">u</span></tt> in front of the string denotes that it is a unicode string, meaning it can represent international characters).:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">shape</span><span class="o">.</span><span class="n">longName</span><span class="p">()</span>
<span class="c"># Result: |pPlane1|pPlaneShape1</span>
<span class="n">shape</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="c"># Result: pPlaneShape1</span>
</pre></div>
</div>
<p>We can also get information specific to this mesh:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">shape</span><span class="o">.</span><span class="n">numEdges</span><span class="p">()</span>
<span class="c"># Result: 220</span>
<span class="n">shape</span><span class="o">.</span><span class="n">numVertices</span><span class="p">()</span>
<span class="mi">121</span>
<span class="sb">`shape.vtx[0]`</span>
<span class="c"># Result: MeshVertex(u&#39;pPlaneShape1.vtx[0]&#39;)</span>
</pre></div>
</div>
<p>On the last line you see that vertices have their own class as well, <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.MeshVertex.html#pymel.core.general.MeshVertex" title="pymel.core.general.MeshVertex"><tt class="xref py py-obj docutils literal"><span class="pre">MeshVertex</span></tt></a>.  More on that later.</p>
<div class="section" id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="Permalink to this headline">¶</a></h3>
<p>I think it&#8217;s time we learned how to set some attributes.  Let&#8217;s go back and take a look at our plane&#8217;s transform and access an <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.Attribute.html#pymel.core.general.Attribute" title="pymel.core.general.Attribute"><tt class="xref py py-obj docutils literal"><span class="pre">Attribute</span></tt></a> object. Just like nodes, attributes have their own class with methods that encompass the dozens of MEL commands for operating on them.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="sb">`plane.translateX`</span>
<span class="c"># Result: Attribute(u&#39;pPlane1.translateX&#39;)</span>
</pre></div>
</div>
<p>To get and set attributes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plane</span><span class="o">.</span><span class="n">translateX</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="c"># Result: 0.0</span>
<span class="n">plane</span><span class="o">.</span><span class="n">translateX</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Here&#8217;s a few examples of how to query and edit properties of attributes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plane</span><span class="o">.</span><span class="n">translateX</span><span class="o">.</span><span class="n">isLocked</span><span class="p">()</span>
<span class="c"># Result: False</span>
<span class="n">plane</span><span class="o">.</span><span class="n">translateX</span><span class="o">.</span><span class="n">setLocked</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plane</span><span class="o">.</span><span class="n">translateX</span><span class="o">.</span><span class="n">isKeyable</span><span class="p">()</span>
<span class="c"># Result: True</span>
<span class="n">plane</span><span class="o">.</span><span class="n">translateX</span><span class="o">.</span><span class="n">setKeyable</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="connections">
<h3>Connections<a class="headerlink" href="#connections" title="Permalink to this headline">¶</a></h3>
<p>Now let&#8217;s look into getting other objects connected to our plane shape.  The <tt class="xref py py-meth docutils literal"><span class="pre">Attribute.connections</span></tt> method accepts the
same flags as the procedural command <tt class="xref py py-obj docutils literal"><span class="pre">listConnections</span></tt>.</p>
<p>Below we get incoming and outgoing connections:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">shape</span><span class="o">.</span><span class="n">connections</span><span class="p">()</span>
<span class="c"># Result: [ShadingEngine(u&#39;initialShadingGroup&#39;), PolyPlane(u&#39;polyPlane1&#39;)]</span>
</pre></div>
</div>
<p><a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.Attribute.html#pymel.core.general.Attribute.inputs" title="pymel.core.general.Attribute.inputs"><tt class="xref py py-obj docutils literal"><span class="pre">inputs</span></tt></a> is a shorcut to <tt class="docutils literal"><span class="pre">connections(source=True)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">shape</span><span class="o">.</span><span class="n">inputs</span><span class="p">()</span>
<span class="c"># Result: [PolyPlane(u&#39;polyPlane1&#39;)]</span>
</pre></div>
</div>
<p><a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.Attribute.html#pymel.core.general.Attribute.outputs" title="pymel.core.general.Attribute.outputs"><tt class="xref py py-obj docutils literal"><span class="pre">outputs</span></tt></a> is a shorcut to <tt class="docutils literal"><span class="pre">connections(source=False)</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">shape</span><span class="o">.</span><span class="n">outputs</span><span class="p">()</span>
<span class="c"># Result: [ShadingEngine(u&#39;initialShadingGroup&#39;)]</span>
</pre></div>
</div>
<p>Notice that when we enable the <tt class="docutils literal"><span class="pre">plugs</span></tt> flag that the result becomes an <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.Attribute.html#pymel.core.general.Attribute" title="pymel.core.general.Attribute"><tt class="xref py py-obj docutils literal"><span class="pre">Attribute</span></tt></a> instead of a node type.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">shape</span><span class="o">.</span><span class="n">inputs</span><span class="p">(</span><span class="n">plugs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># Result: [Attribute(u&#39;polyPlane1.output&#39;)]</span>
</pre></div>
</div>
<p>Here&#8217;s another handy feature of python: it supports 2D arrays, meaning you can put lists inside lists.  PyMEL takes advantage of that in many situations, including when we enable the <tt class="docutils literal"><span class="pre">connections</span></tt> flag, which causes <tt class="xref py py-obj docutils literal"><span class="pre">listConnections</span></tt> to list source-destination pairs.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">shape</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># Result: [(Attribute(u&#39;pPlaneShape1.instObjGroups[0]&#39;), Attribute(u&#39;initialShadingGroup.dagSetMembers[0]&#39;)), (Attribute(u&#39;pPlaneShape1.inMesh&#39;), Attribute(u&#39;polyPlane1.output&#39;))]</span>
</pre></div>
</div>
<p>This is particularly useful for looping</p>
<div class="highlight-python"><pre>for source, destination in shape.connections(c=1, p=1):
...     print source, destination</pre>
</div>
<div class="highlight-none"><div class="highlight"><pre>pPlaneShape1.instObjGroups[0] initialShadingGroup.dagSetMembers[0]
pPlaneShape1.inMesh polyPlane1.output
</pre></div>
</div>
</div>
<div class="section" id="using-existing-objects-by-name">
<h3>Using Existing Objects by Name<a class="headerlink" href="#using-existing-objects-by-name" title="Permalink to this headline">¶</a></h3>
<p>In many cases, you won&#8217;t be creating objects directly in your code, but will want to gain access to an existing object by name. PyMEL provides two ways of doing this. Both of them will automatically choose the correct PyMEL class for your object.</p>
<p>The <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode" title="pymel.core.general.PyNode"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode</span></tt></a> class:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">PyNode</span><span class="p">(</span> <span class="s">&#39;defaultRenderGlobals&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">startFrame</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="c"># Result: 1.0</span>
</pre></div>
</div>
<p>The SCENE object ( an instance of the <tt class="xref py py-obj docutils literal"><span class="pre">Scene</span></tt> class )</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">SCENE</span><span class="o">.</span><span class="n">defaultRenderGlobals</span><span class="o">.</span><span class="n">startFrame</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="c"># Result: 1.0</span>
</pre></div>
</div>
</div>
<div class="section" id="mel-scripts">
<h3>Mel Scripts<a class="headerlink" href="#mel-scripts" title="Permalink to this headline">¶</a></h3>
<p>Calling MEL scripts through <tt class="docutils literal"><span class="pre">maya.mel.eval</span></tt> is a nuisance because it requires so much string formatting on
the programmer&#8217;s part.  <tt class="docutils literal"><span class="pre">pymel.mel</span></tt> handles all of that for you so you can use your MEL scripts as if they
were python functions. This includes automatically formatting all iterable types into maya arrays.</p>
<p>See out <a class="reference internal" href="generated/classes/pymel.core.language/pymel.core.language.Mel.html#pymel.core.language.Mel" title="pymel.core.language.Mel"><tt class="xref py py-obj docutils literal"><span class="pre">pymel.core.language.Mel</span></tt></a> for more information.</p>
</div>
</div>
<div class="section" id="transitioning-tips">
<h2>Transitioning Tips<a class="headerlink" href="#transitioning-tips" title="Permalink to this headline">¶</a></h2>
<div class="section" id="what-to-change">
<h3>What to Change<a class="headerlink" href="#what-to-change" title="Permalink to this headline">¶</a></h3>
<p>All of the MEL functions in <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> exist in <tt class="docutils literal"><span class="pre">pymel</span></tt>, with a few exceptions ( see <a class="reference internal" href="modules.html"><em>Package Namespace Index</em></a> ).  MEL functions that operate on nodes and/or attributes almost always fall into one or more of these categories:  creating, listing, querying/editing.  As you begin shifting toward a more object-oriented approach, you will still retain the need for procedural programming.
Use these guidelines for what aspects of PyMEL are best suited to object-oriented programming:</p>
<blockquote>
<div><ol class="arabic simple">
<li>creating nodes and UI elements : remains mostly procedural</li>
<li>listing objects and UI elements:  object-oriented, except for general listing commands like <tt class="xref py py-obj docutils literal"><span class="pre">ls</span></tt></li>
<li>querying and editing objects and UI elements:  object-oriented, except for commands that operate on many nodes at once, like <tt class="xref py py-obj docutils literal"><span class="pre">select</span></tt> and <tt class="xref py py-obj docutils literal"><span class="pre">delete</span></tt></li>
</ol>
</div></blockquote>
</div>
<div class="section" id="partial-conversion-is-bad-mmkay">
<h3>Partial Conversion is Bad, mmkay<a class="headerlink" href="#partial-conversion-is-bad-mmkay" title="Permalink to this headline">¶</a></h3>
<p>Mixing <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> module with <tt class="docutils literal"><span class="pre">pymel.core</span></tt> will result in problems, because <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> doesn&#8217;t know what to do with anything other than very basic data types. Passing a <a class="reference internal" href="generated/classes/pymel.core.general/pymel.core.general.PyNode.html#pymel.core.general.PyNode" title="pymel.core.general.PyNode"><tt class="xref py py-obj docutils literal"><span class="pre">PyNode</span></tt></a>, <a class="reference internal" href="generated/classes/pymel.core.datatypes/pymel.core.datatypes.Matrix.html#pymel.core.datatypes.Matrix" title="pymel.core.datatypes.Matrix"><tt class="xref py py-obj docutils literal"><span class="pre">Matrix</span></tt></a>, <a class="reference internal" href="generated/classes/pymel.core.datatypes/pymel.core.datatypes.Vector.html#pymel.core.datatypes.Vector" title="pymel.core.datatypes.Vector"><tt class="xref py py-obj docutils literal"><span class="pre">Vector</span></tt></a>, or other custom type to a <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> function will result in errors.  Your best bet is to completely replace <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> with <tt class="docutils literal"><span class="pre">pymel</span></tt> throughout your code in one go.  This might sound frightening, but it will ultimately lead to fewer errors than partial PyMEL integration.  The  purely procedural part of <tt class="docutils literal"><span class="pre">pymel.core</span></tt> will behave exactly the same as <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> as long as it is replaced wholesale, but if it is not, results returned from PyMEL functions will cause errors when passed to <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> functions, and results from <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> will need to be cast to PyNodes.</p>
<p>There are only a handful of <tt class="docutils literal"><span class="pre">maya.cmds</span></tt> wraps in PyMEL that are not backward compatible. They all fall into the category of functions which now return a list of tuple pairs instead of a flat list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">listConnections</span><span class="p">(</span> <span class="n">connections</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
<span class="n">keyframe</span><span class="p">(</span> <span class="n">q</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">valueChange</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
<span class="n">keyframe</span><span class="p">(</span> <span class="n">q</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeChange</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
<span class="n">ls</span><span class="p">(</span> <span class="n">showType</span><span class="o">=</span><span class="bp">True</span> <span class="p">)</span>
</pre></div>
</div>
<p>These changes are all noted in the docstrings of each function.</p>
</div>
</div>
<div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="glossary docutils">
<dt id="term-methods">methods</dt>
<dd>a method is a function bound to an object. ex. &#8216;bar&#8217; is the method in <tt class="docutils literal"><span class="pre">foo.bar()</span></tt></dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Getting Started</a><ul>
<li><a class="reference internal" href="#formatting-read-me-first-to-avoid-confusion">Formatting: Read Me First to Avoid Confusion</a></li>
<li><a class="reference internal" href="#example-1-the-basics">Example 1: The Basics</a><ul>
<li><a class="reference internal" href="#importing-pymel">Importing PyMEL</a></li>
<li><a class="reference internal" href="#an-intro-to-pymel-objects-in-maya">An Intro to PyMEL Objects in Maya</a></li>
<li><a class="reference internal" href="#getting-help">Getting Help</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-2-transitioning-from-procedural-programming">Example 2: Transitioning from Procedural Programming</a></li>
<li><a class="reference internal" href="#example-3-some-more-oo-basics">Example 3: Some More OO Basics</a><ul>
<li><a class="reference internal" href="#attributes">Attributes</a></li>
<li><a class="reference internal" href="#connections">Connections</a></li>
<li><a class="reference internal" href="#using-existing-objects-by-name">Using Existing Objects by Name</a></li>
<li><a class="reference internal" href="#mel-scripts">Mel Scripts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#transitioning-tips">Transitioning Tips</a><ul>
<li><a class="reference internal" href="#what-to-change">What to Change</a></li>
<li><a class="reference internal" href="#partial-conversion-is-bad-mmkay">Partial Conversion is Bad, mmkay</a></li>
</ul>
</li>
<li><a class="reference internal" href="#glossary">Glossary</a></li>
</ul>
</li>
</ul>



  <h4>Previous topic</h4>
  <p class="topless"><a href="why_pymel.html"
                        title="previous chapter">Why PyMEL?</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pynodes.html"
                        title="next chapter">PyNodes</a></p>
<h3><a href="modules.html">Core</a></h3>
<ul>   
	<li><a class="reference external" href="generated/pymel.core.animation.html#module-pymel.core.animation"><tt class="xref">animation</tt></a></li>
	<li><a class="reference external" href="generated/pymel.core.effects.html#module-pymel.core.effects"><tt class="xref">effects</tt></a></li>
	<li><a class="reference external" href="generated/pymel.core.general.html#module-pymel.core.general"><tt class="xref">general</tt></a></li>
	<li><a class="reference external" href="generated/pymel.core.language.html#module-pymel.core.language"><tt class="xref">language</tt></a></li>
	<li><a class="reference external" href="generated/pymel.core.modeling.html#module-pymel.core.modeling"><tt class="xref">modeling</tt></a></li>
	<li><a class="reference external" href="generated/pymel.core.rendering.html#module-pymel.core.rendering"><tt class="xref">rendering</tt></a></li>
	<li><a class="reference external" href="generated/pymel.core.system.html#module-pymel.core.system"><tt class="xref">system</tt></a></li>
	<li><a class="reference external" href="generated/pymel.core.windows.html#module-pymel.core.windows"><tt class="xref">windows</tt></a></li>
</ul>
<h3><a href="modules.html">Core Modules</a></h3>
<ul> 
	<li><a class="reference external" href="generated/pymel.core.datatypes.html#module-pymel.core.datatypes"><tt class="xref">datatypes</tt></a></li>
	<li><a class="reference external" href="generated/pymel.core.nodetypes.html#module-pymel.core.nodetypes"><tt class="xref">nodetypes</tt></a></li>  
	<li><a class="reference external" href="generated/pymel.core.uitypes.html#module-pymel.core.uitypes"><tt class="xref">uitypes</tt></a></li>  
</ul>
<h3><a href="modules.html">Other Modules</a></h3>
<ul>
	<li><a class="reference external" href="generated/pymel.api.html#module-pymel.api"><tt class="xref">api</tt></a></li> 
	<li><a class="reference external" href="generated/pymel.mayautils.html#module-pymel.mayautils"><tt class="xref">mayautils</tt></a></li>
	<li><a class="reference external" href="generated/pymel.util.html#module-pymel.util"><tt class="xref">util</tt></a></li>
	<li><a class="reference external" href="generated/pymel.versions.html#module-pymel.versions"><tt class="xref">versions</tt></a></li>
</ul>




<!--
<ul>   
<li><a class="reference external" href="generated/pymel.core.animation.html.html#module-pymel.core.animation"><tt class="xref">animation</tt></a></li>
<li><a class="reference external" href="generated/pymel.core.datatypes.html.html#module-pymel.core.datatypes"><tt class="xref">datatypes</tt></a></li>
<li><a class="reference external" href="generated/pymel.core.effects.html.html#module-pymel.core.effects"><tt class="xref">effects</tt></a></li>
<li><a class="reference external" href="generated/pymel.core.general.html.html#module-pymel.core.general"><tt class="xref">general</tt></a></li>
<li><a class="reference external" href="generated/pymel.core.language.html.html#module-pymel.core.language"><tt class="xref">language</tt></a></li>
<li><a class="reference external" href="generated/pymel.core.modeling.html.html#module-pymel.core.modeling"><tt class="xref">modeling</tt></a></li>
<li><a class="reference external" href="generated/pymel.core.nodetypes.html.html#module-pymel.core.nodetypes"><tt class="xref">nodetypes</tt></a></li>
<li><a class="reference external" href="generated/pymel.core.rendering.html.html#module-pymel.core.rendering"><tt class="xref">rendering</tt></a></li>
<li><a class="reference external" href="generated/pymel.core.system.html.html#module-pymel.core.system"><tt class="xref">system</tt></a></li>
<li><a class="reference external" href="generated/pymel.core.windows.html.html#module-pymel.core.windows"><tt class="xref">windows</tt></a></li>
<li><a class="reference external" href="generated/pymel.util.html.html#module-pymel.util"><tt class="xref">pymel.util</tt></a></li>

</ul>
-->

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/tutorial.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pynodes.html" title="PyNodes"
             >next</a> |</li>
        <li class="right" >
          <a href="why_pymel.html" title="Why PyMEL?"
             >previous</a> |</li>
        <li><a href="index.html">PyMEL v1.0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2009, Chad Dombrova.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>